#!/usr/bin/env python 
import os
import numpy
import random
import math
from scipy.stats import scoreatpercentile

# Expectation-Maximization functions
# -------------------------------------

# M-step functions:
# -------------------


# Prior probability
def pi_k_learning(ek, N):
    return ek/N

# Center (mu)
def mu_k_learning(num_k, ek, gamma, N, D, coordinates):
    mu = numpy.matrix([[0] for _ in xrange(D)])
    for i in xrange(N):
       p = gamma[num_k][i]
       point = getPoint(coordinates,i)
       mu += p*point
    mu = mu/ek
    return mu

# Covariance matrix (sigma)
def sigma_k_learning(num_k, ek, gamma, N, D, mu, coordinates):
    sig = numpy.matrix([[0.0 for _ in xrange(D)] for _ in xrange(D)])
    for i in xrange(N):
        pt = getPoint(coordinates, i)
        s = pt-mu
        sig = sig + (gamma[num_k][i]*(s*s.transpose()))
    sig = sig/ek
    # Add a tiny variance to avoid numerical instability (Calinon09)
    sig += (numpy.eye(D)*0.5)
    try:
        numpy.linalg.cholesky(sig)
    except numpy.linalg.LinAlgError:
        print "Sigma learning: Covariance matrix non positive-definite!:"
        print str(sig)
        pass
    return sig

# E-step functions:
# -------------------

# Sum of posterior probabilities E_k
def Ek(num_k, gamma):
    ek = sum(gamma[num_k])
    return ek

# Posterior probability P_k,j
def pkj(point, num_k, D, K, k, mus, sigmas):
    s = point_GMM_prob(point, D, K, k, mus, sigmas)
    return (k[num_k]*density(point, D, mus[num_k], sigmas[num_k]))/(s + 1e-16)


# GMM functions:
# -------------------

# Log-likelihood of the observed data generated by the model
def log_likelihood(N,K,D,k,mus,sigmas,coordinates):
    s = 0.0
    for i in xrange(N):
        prob = point_GMM_prob(getPoint(coordinates,i),D, K, k, mus, sigmas) + 1e-16
        #print "Point: " + str(getPoint(coordinates, i)) + ". Prob: " + str(prob)
        s += math.log(prob)
    return s/numpy.double(N)

# Normalized sum of probabilities of the datapoints of a demonstration on a given GMM
def prob_datapoints_GMM(N,K,D,k,mus,sigmas,coordinates):
    s = 0.0
    for i in xrange(N):
        prob = point_GMM_prob(getPoint(coordinates,i),D, K, k, mus, sigmas) + 1e-16
        #print "Point: " + str(getPoint(coordinates, i)) + ". Prob: " + str(prob)
        s += prob
    return s

# Probability that a datapoint belongs to the GMM
def point_GMM_prob(point,D,K,k,mus,sigmas):
    s = 0
    for i in xrange(K):
       dens = density(point, D,  mus[i], sigmas[i])
       s += k[i]*dens
    return s

# Gaussian conditional probability density function (pdf)
def density(point, D, mu, sigma,debugPrint=False):
            
    sub = point-mu
    det = numpy.linalg.det(sigma)
    
    if det != 0:
        s =  ((math.exp(-0.5*((sub.transpose())*(sigma.I)*sub)))/(math.sqrt(math.pow(2*math.pi, D)*det)))
        return s
    else:
       return 0.0

# Outliers functions:
# -------------------
# Mahalanobis distance of a given point
def mahalanobis(point, center, cov_inv):
    sub = point - center
    return math.sqrt(sub.transpose() * cov_inv * sub)

# Other functions:
#---------------------
# Returns a numpy.matrix of the i-th point
def getPoint(coordinates, i):
    dim = len(coordinates)
    point = [[] for _ in xrange(dim)]
    for j in xrange(dim):
       point[j].append(coordinates[j][i])
    return numpy.matrix(point)


def outlier_removal(coordinates):
    D=len(coordinates)
    N=len(coordinates[0])
    # Mahalanobi distances (1xN)
    mahalanobis_dist = []
    # Outliers removal
    # ------------------------------------------------

    # Center of the point cloud
    cloud_center = numpy.matrix([[numpy.mean(coordinates[0])]])
    for i in xrange(1,D):
        cloud_center = numpy.concatenate((cloud_center,numpy.matrix(numpy.mean(coordinates[i]))), axis=0)
    
    # Covariance matrix (DxD)
    cov_matrix = numpy.matrix(numpy.cov(coordinates))
    cov_matrix_I = cov_matrix.I

    # Mahalanobis distance of each point
    for i in xrange(N):
        mahalanobis_dist.append(mahalanobis(getPoint(coordinates, i), cloud_center, cov_matrix_I))
    
    # 2,5 and 97,5 percentile limits
    left_lim = scoreatpercentile(mahalanobis_dist, 2.5)
    right_lim = scoreatpercentile(mahalanobis_dist, 97.5)

    # Outliers removal
    num_del = 0
    for dist in mahalanobis_dist:
        if dist <= left_lim or dist >= right_lim:
            i = mahalanobis_dist.index(dist)
            mahalanobis_dist.pop(i)
            for j in xrange(D):
                coordinates[j].pop(i)
            num_del += 1
    N -= num_del
    print "New N = " + str(N) + "; " + str(num_del) + " points have been removed."
    return coordinates